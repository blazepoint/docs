# Events

An event is the base layer of the protocol. Events are durable, immutable, and can (in theory) be used to derive the full state of the system, excluding server policy and request/response state. Events MUST be signed by the originating account and verified by both client and server. All events share a common structure:

- id: a unique identifier consisting of the event's `key`, `instance`, and `ordinal` joined by the `.` character.
- path: list of objects describing the path taken by the event. The first entry is the originating account.
  - key: public key of the signing account
  - timestamp: ISO 8601-1 timestamp generated by the signer
  - signature: signature of the entire event, including all path entries up to this entry
- topic: any string, convention is to namespace with slashes, e.g. `account/create`
- payload: a topic-specific json/utf-8-encoded object containing event details
- created: an ISO 8601-1 timestamp showing when the event was created
- key: the public key of the originating account
- instance: a random string that identifies the instance of the originating account
- ordinal: an integer generated by the client to indicate which event this is in the instance's series.

Servers MUST validate that all signatures are valid and each final signature matches the sender of the event. Servers MUST also validate payload structure based on the given topic before persisting the event or relaying it. [JSON Schema](https://json-schema.org/) SHOULD be used to perform payload validation. Servers MUST validate that events are no more than 50KB in size.

If an event's signature is invalid, the server MUST return an `invalid-signature` error. If an event's payload is invalid, the server MUST return an `invalid-payload` error.

In order to avoid platform-specific irregularities, like json encoding/decoding defaults, signatures should be based on the concatenation of topic, payload, instance, ordinal, each path's key, timestamp, and signature, encoded as utf-8, and stored in `path` hex-encoded.

# Gossip

Gossip is primarily accomplished using client hints - that is, depending on how a user interacts with certain content, a client may publish replication requests to servers it is connected to. The idea here is that the network topology ought to match the topology of the actual social network. This enables interesting emergent behavior with regards to scaling and moderation.

Client hints are complemented by some direct collaboration between servers, allowing for more efficient use of bandwidth and access to more complete and up-to-date content (in contrast to e.g. Scuttlebutt). Servers SHOULD NOT gossip between themselves, except to fulfill client requests.

A client MAY connect with one or more servers (ideally two or more). Clients MAY allow a user to specify whether a server should be published to, or only read from. Clients SHOULD make a good effort to publish events to all publishable servers, queueing them up to be re-tried in case of network or server failure.

Servers SHOULD implement support for peer gossip (otherwise a server would only be able to share content directly published with it). This support MUST be indicated at `/info`. See the API section of this documentation for more information.

When a client connects to a new server, it SHOULD notify it of other known servers in the network at `/servers`. The server MUST then request the full server info from each recommended server's `/info` endpoint to fill in name and description. A server's record should have no id, and MUST be identified by its `url`. If a server moves, a new server record is created.

Servers MUST publish a list of servers via the `/record/server`, but MAY omit peers from the list at their discretion.

Whenever a server receives an event it SHOULD check for missing context. This can be done either eagerly, or on demand when the content is requested. Which strategy is implemented depends on the use case and size of data. Context may include basic account data, or topic-specific context like comments, votes, etc. If any context is missing, the server SHOULD request it from known peers using the `/request` endpoint.

On occasion, servers MAY push events to other servers directly using the `/publish` endpoint, for example when propagating an `account/delete` request. Receiving servers SHOULD validate the `Authorization` header and compare the provided public key to the final key in each event's `path`, rejecting events that do not have a topic that should be aggressively gossiped, or that did not originate with the sender.

Servers MAY delete infrequently requested content to keep storage low, or eagerly replicate popular content. To allow for batching and high cardinality broadcasting, eager replication should be implemented asynchronously.

# Monetization

Accounts may specify wallets in order to receive payments for content produced.

Payments are federated rather than truly decentralized; node operators collect micropayments from clients (batched to keep transaction fees low) based on content served and use that liquidity to cover costs and pay content producers. This has the effect of throttling social media addiction, because you're paying actual money. This payment strategy should have a free tier, and cost different amounts based on serving heavy content or requesting unavailable content.

Payouts should be disbursed on a delayed time frame, based on replication votes for a given identity.

# Extensions

This protocol is designed to be extensible. Custom event topics and record attributes may be defined, but must begin with `ext.name/`. Servers SHOULD list all known extensions along with their complete definition (record/event schemas) at `/info`. Servers may omit any extensions it prefers not to support or know about.

An example extension might implement a chess game by defining `ext.chess/game` and `ext.chess/move` records, along with `ext.chess/start` and `ext.chess/move` event topics.

---

# Records

A record is the representation of a domain-specific system object.

All records MUST have an `eid`, which is identical to the originating event's `id`, making it possible to infer originating `account` and other meta data such as `created` timestamp. Servers MAY further optimize relationships internally by creating numeric or other foreign key relationships between records and events, accounts, etc. However, servers also MUST tolerate missing data.

The exception to this is records that enter the system without being published via an event (for example, servers and blobs). These records will not have a `gid`, but must be uniquely identifiable by some other attribute. In the case of servers, this would be `url`.

When publishing events that perform privileged operations on records, implementations MUST check whether the account attempting the operation has permission. This can help to avoid client attacks on existing records using the same id.

## Server

Schema: `{url: str, name: str, description: str}`

## Account

Schema: `{key: str, handle: str, avatar: url, description: str, sharing: none|local|network}`

An account is record that representats a user's interaction with the network. A server MUST implement account registration and privacy controls. See API for more details. An account is identified by its public key. Signatures, public key and encodings are done according to the [Schnorr signatures standard for the curve secp256k1](https://bips.xyz/340).

A client MUST store an account's full event history as well as synchronization state, etc. This may be persisted using a third-party service, or directly on the user's device, but in any case an account's data MUST be encrypted at rest using a password supplied by the user.

An account may specify `sharing` settings as follows:

- `none` means content should not be displayed except to mutual followers (account page is still public)
- `local` means content should not be gossiped to other servers
- `network` means content may be gossiped to the broader network

Server and client implementations SHOULD respect account sharing preferences.

Servers SHOULD honor account deletion requests. The purpose of this endpoint is to remove sensitive information from the system, not to re-write event history. Since implementations need to be able to handle missing data anyway, the simplest implementation here would be to delete all events and records published by the account, other than the account deletion request itself, which would be agressively propagated through the system.

## Instance

Schema: `{identifier: str, name: str}`

An `instance` identifies a client/account pair, e.g. "Jim's Desktop". An instance is automatically created when an account sends its first message with a given instance. Servers and clients MAY support renaming this instance, and displaying it where relevant.

## Vote

Schema: `{record_type: str, record_id: str, score: float}`

A `vote` is a request by a user to replicate and otherwise prioritize certain content. Votes MAY be applied to any record type. Score is a float ranging from -1 to 1. If a user votes multiple times, the record MUST be upserted. Clients MAY choose what UI elements constitute a vote; they may have explicit vote functionality, or implement votes based on likes, follows, blocks, etc.

If content is voted up, that vote is shared with all of a client's connected servers. Those servers SHOULD then make an effort to acquire that content and its context (related posts, comments, accounts) and serve that content to its own clients as appropriate.

Content's overall score SHOULD affect how likely it and content from the originating account is to be recommended to other users in `feeds`. Negative scores SHOULD outweigh positive scores, so clients should be careful to only register a down vote in the case of block/mute type actions rather than mere downvotes. The goal of this system is to implement a recommendation system as well as distributed moderation by means of the social graph itself.

## Blob

Schema: `{content_type: str, canonical_url: str, mirror_url: str}`

A blob is just a record that represents some arbitrary binary data with an associated content type. Servers MAY implement the `/blob` endpoints described in the API section of this document. `canonical_url` is the effective identifier for a blob, representing its original location. `mirror_url` should be the server's best guess at a working url for the blob, and may change as links break and replicas are created.

For example: a blob may be created with the canonical_url pointing somewhere on the wider internet. A server may simply copy the canonical url to the mirror url field, or it may eagerly download the media and point its mirror_url to its own copy. Another server receiving a replica of the blob record may choose either url to use as the mirror_url, or further replicate the content.

## Post

Schema: `{body: str, content_type: str, deleted: timestamp, parent_type: post|account|server, parent_id: str}`

A post is the basic, standalone implementation of a piece of shared content. It is simply a blob of text, limited to 1024 characters. Content type may be `text` or [`gfm`](https://github.github.com/gfm/). Posts may be nested arbitrarily deep forum-style by including a reference to its parent.

Clients SHOULD implement rich text composition and rendering, including links, @-mentions, topics, inline images, videos, and site previews. Clients SHOULD render annotations alongside the original post, and hide the post and annotations if deleted. Servers MUST implement deletions as soft-deletions by setting the `deleted` timestamp and redacting the `body` of the post.

For all media included in a post, clients MAY extract the urls and search for blobs whose `canonical_url` matches the media url, falling back to `mirror_url`

## Annotation

Schema: `{post_id, body: str, content_type: str}`

An annotation is an addendum to a post. This is specified in lieu of updates, to avoid confusing or malicious edits while providing a platform for the original author to draw attention to new information or corrections to the original post.

## Tag

Schema: `{handle: str, record_type: post|annotation|account, record_id: uuid}`

Tags are strings prefixed by `#`, and SHOULD be extracted by clients from the body of posts, annotations, and account bodies and published.

## Mention

Schema: `{handle: str, target: str, record_type: post|annotation|account, record_id: uuid}`

A mention is a reference to an account, including a mapping between handle (since they may be non-unique) and the account's public key. It is a client's responsibility to extract mentions from content and publish them.

Mentions SHOULD be implemented on the client by determining the mapping between an account's handle and public key at post composition time. The handle should be embedded in the post, and mapped to a key in the `mentions` list.

# Subscription

Schema: `{record_type: account|topic, record_id: uuid}`

A subscription registers an account's interest in following an account or topic.

## Group

Schema: `{name: str, private: bool}`

# Membership

Schema: `{group_id: str, account_id: str}`

# Wallet

Schema: `{type: bitcoin, address: str}`

---

# Events

A complete list of standard events is included below. Each event type is defined by a `topic`, which consists of a namespace and a name joined by a slash.

- `account/create {handle, avatar, description, sharing}`
- `account/update {handle, avatar, description, sharing}`
- `account/delete {}`
- `instance/update {identifier, name}`
- `vote/create {gid, record_id, record_type, score}`
- `vote/delete {gid}`
- `server/recommend {servers: [{url}]}`
- `post/create {gid, body, parent_type, parent_id}`
- `post/delete {gid}`
- `annotation/create {gid, post_id, body, content_type}`
- `tag/create {gid, handle, record_type, record_id}`
- `mention/create {gid, handle, target, record_type, record_id}`
- `subscription/create {gid, record_type, record_id}`
- `subscription/delete {gid}`
- `group/create {gid, name, private}`
- `group/invite {gid: str, account_id: str}`
- `group/join {gid: str}`
- `group/leave {gid: str}`
- `wallet/create {type: bitcoin, address: str}`
- `wallet/delete {str: str}`

---

# HTTP API

Servers MUST implement certain https API endpoints as specified below. Servers MAY implement additional endpoints as required by additional sections of this protocol.

Every request MUST be accompanied by an `Authorization` header using the [bearer](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization#bearer) directive. The value of this header MUST be a [JWT](https://jwt.io/introduction) where `alg` is `secp256k1`, `iss` is the account's public key, `aud` is the server's url, and `exp` is set to the desired expiration time. The signature should be encrypted using the account's private key. Servers SHOULD validate this header.

## Errors

If any request is invalid, a 4XX response should be returned including an `error` key with the following schema: `{code: str, message: str, path: [str]}`, where `code` is a standard error code, `message` is a human-readable error message, and `path` is an optional list of strings specifying where in the request the error originated.

Errors may be used to request payment of fees, request account registration, or otherwise indicate request errors.

- `auth/unauthorized`
- `auth/forbidden`
- `auth/register`
- `payload/content-type`
- `payload/required`
- `event/invalid-signature`
- `event/invalid-payload`
- `schema/<jsonschema error code>`

> The following endpoints are intended to be accessible regardless of account registration status.

## `GET /info`

Servers MUST implement an `/info` endpoint accepting a GET request. This is where a server describes itself, including what protocol features it supports, as well as more granular configuration for certain extensions.

- `url` is the server's base url
- `name` is the server's self-assigned name
- `description` is the server's self-assigned description in `gfm` format

## `POST /server`

This allows servers to propagate known servers through the system, strengthening the network.

## `GET /ext`

Returns an object whose keys are the unqualified name of an extension. Each extension describes additional records and event topics (see examples/chess.md for an example). If a client attempts to use an extension not recognized by the server, the server MUST return an `ext/unknown` error.

## `POST /ext`

Registers an extension with a server. This must match the following schema: TODO

## `GET /fees`

Returns an object with the key `items` which is a list of objects of the form `{amount: number, type: str, usage: unit}`. `type` may be the name of a feed prefixed by `feed/`, the name of an event topic, or one of `content/rich`, `content/image`, `content/video` for denoting different types of content the user is asking the server to host. `usage` may specify a unit, each of which costs `amount`.

## `POST /register`

An account MUST attempt to register itself with a server before accessing non-metadata endpoints (any endpoints defined below). This does not require the account to exist in the network yet, it is only a request for permission for a public key. Request schema is `{key: str}`. A successful registration is indicated by a `{success: true}` response. A failed registration is indicated by a standard error response, where `code` is one of the following:

- `registration/denied` indicates that the server is not accepting new registrations.
- `registration/delayed` indicates that the server is not accepting new registrations at this time.
- `registration/invoice` indicates an invoice must be paid before registration can complete. Response should include an `invoice` key.
- `registration/contact` indicates registration must be brokered external to the system. `message` should explain how registration should be accomplished.

Any of the above response codes can be used for any protected endpoint, indicating a user's registration has been revoked or needs to be maintained.

> The following endpoints are intended to be accessible only to registered users.

## `POST /publish/:topic`

This endpoint MUST accept multiple events. Schema is `{events: [event]}` where `[event]` is a list of event objects as specified above. Servers SHOULD validate that the final key in each event `path` matches the key provided in the `Authorization` header.

## `POST /blob`

Servers MAY implement blob storage at `/blob`. This endpoint accepts either a file upload or a json payload specifying a file url.

## `GET /blob/:url`

Allows a client to retrieve blob information for a given canonical url.

## `POST /message`

Servers MAY implement private messaging at `/message`. TODO

## `GET /message`

Allows a client to retrieve a list of message threads. TODO

## `GET /message/:thread`

Allows a client to retrieve a list of messages for a given thread. TODO

## `POST /query`

Allows a client to retrieve a list of records. Payload is as follows:

```
{
  handle: str,
  type: str,
  where: [filter],
  order: [str, str],
  limit: int,
}
```

- `handle` is a random string identifying the query for subsequent requests.
- `type` is the name of any `record` or `feed`.
- `where` is a potentially recursive list of tuples specifying `[operator, condition]`
  - Where `condition` is a tuple of [`field`, `value`], `operator` is one of `=`, `!=`, `!=`, `>`, `<`, `>=`, `<=`
  - Where `condition` is a list of `where`s, `operator` is one of `and`, `or`, `not`.
- `order` is a tuple of `[field, direction]` where `direction` is one of `asc`, `desc`
- `limit` is an integer specifying how many records to return.

Upon receiving a query request, servers MUST query its internal database and return records that match the query, storing the query for subsequent paginated requests. Response is as follows:

```
{
  next: str?,
  prev: str?,
  total: int,
  data: [object],
}
```

## `GET /query/:cursor`

Clients may request subsequent pages for a query, where `cursor` is a value from either the `prev` or `next` keys of the response. This endpoint returns a standard response as described above.

## `POST /search`

A global search endpoint. Accepts a POST with a JSON payload:

Schema: `{query: str, only: [accounts|posts|topics|comments|groups]?}`

Response is the same as `/query`.

---

# Websocket API

`/list` and `/publish` functionality MAY also be exposed using a websocket connection at `/connect`. All messages should be JSON-encoded arrays. Events may be published thus: `["publish", <event payload>]`. A client may subscribe to the result of a particular query by sending a request like this: `["list", <channel-name>, <query>]`, returning the `data` property of the `/query` endpoint's response.

A client may close a channel by sending `["close", <channel-name>]`.
