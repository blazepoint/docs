# Events

An event is the base layer of the protocol. Events are durable, immutable, and can (in theory) be used to derive the full state of the system, excluding server policy and request/response state. Events MUST be signed by the originating account and verified by both client and server. All events share a common structure:

- path: list of objects describing the path taken by the event. The first entry is the originating account.
  - key: public key of the signing account
  - timestamp: ISO 8601-1 timestamp generated by the signer
  - signature: signature of the entire event, including all path entries up to this entry
- topic: any string, convention is to namespace with slashes, e.g. `account/create`
- payload: a topic-specific json/utf-8-encoded object containing event details
- created: an ISO 8601-1 timestamp showing when the event was created
- key: the public key of the originating account
- instance: a random string that identifies the instance of the originating account
- ordinal: an integer generated by the client to indicate which event this is in the instance's series.

Servers MUST validate that all signatures are valid and each final signature matches the sender of the event. Servers MUST also validate payload structure based on the given topic before persisting the event or relaying it. [JSON Schema](https://json-schema.org/) SHOULD be used to perform payload validation. Servers MUST validate that events are no more than 50KB in size.

If an event's signature is invalid, the server MUST return an `invalid-signature` error. If an event's payload is invalid, the server MUST return an `invalid-payload` error.

In order to avoid platform-specific irregularities, like json encoding/decoding defaults, signatures should be based on the concatenation of topic, payload, instance, ordinal, each path's key, timestamp, and signature, encoded as utf-8, and stored in `path` hex-encoded.

# Records

A record is the representation of a domain-specific system object.

All records MUST have a `gid` which is the the originating event's `key`, `instance`, and `ordinal` joined by the `.` character. Multiple record types MAY have the same `gid`, but no two records of the same type may have the same `gid`. A record's `gid` will always be identical to the `gid` of its originating event, making it possible to infer originating `account` and other meta data such as `created` timestamp.

For simplicity, all records related to an account MUST have a `key` attribute referencing the originating account. Servers MAY further optimize relationships internally by creating numeric or other foreign key relationships between records and events, accounts, etc. However, servers also MUST tolerate missing data.

There are two exceptions to this:

- Accounts, which are identified by their `key`, and instances which are identified by their `identifier`.
- Non-social records, which are records that enter the system without being published by an account, for example servers. These records will not have a `gid`, but must be uniquely identifiable by some other attribute. In the case of servers, this would be `url`.

When performing privileged operations on records, implementations MUST check whether the account attempting the operation has permission. This can help to avoid client attacks on existing records using the same id.

# API

Servers MUST implement certain https API endpoints as specified below. Servers MAY implement additional endpoints as required by additional sections of this protocol.

Every request MUST be accompanied by an `Authorization` header using the [bearer](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization#bearer) directive. The value of this header MUST be a [JWT](https://jwt.io/introduction) where `alg` is `secp256k1`, `iss` is the account's public key, `aud` is the server's url, and `exp` is set to the desired expiration time. The signature should be encrypted using the account's private key. Servers SHOULD validate this header.

If any request is invalid, a response should be returned including an `error` key with the following schema: `{code: str, message: str, path: [str]}`, where `code` is a standard error code (see `/protocol/errors.md` for details), `message` is a human-readable error message, and `path` is an optional list of strings specifying where in the request the error originated.

## `/info`

Servers MUST implement an `/info` endpoint accepting a GET request. This is where a server describes itself, including what protocol features it supports, as well as more granular configuration for certain extensions.

- `url` is the server's base url
- `name` is the server's self-assigned name
- `description` is the server's self-assigned description in `gfm` format
- `features` describes supported protocol features.
- `fees` describes how fees are collected

`features` is an object whose keys are the names of features defined in this protocol, and whose values are either the string `all`, or an object specifying feature support more granularly. Valid keys are `publish`, `request`, `gossip`.

`fees` is an object with the key `items` which is a list of objects of the form `{amount: number, type: str, usage: unit}`. `type` may be the name of a feed prefixed by `feed/`, the name of an event topic, or one of `content/rich`, `content/image`, `content/video` for denoting different types of content the user is asking the server to host. `usage` may specify a unit, each of which costs `amount`.

## `/publish`

Events are published by sending a POST request to `/publish`. This endpoint MUST accept multiple events. Schema is `{events: [event]}` where `[event]` is a list of event objects as specified above. Servers SHOULD validate that the final key in each event `path` matches the key provided in the `Authorization` header.

Servers MUST advertise support at `/info` by including `publish: "all"` in the features object.

## `/request`

Events, records, and feeds may be retrieved by sending a POST request to the `/request` endpoint. Feeds are special purpose views into the system that a server MAY implement (see [Feeds](/protocol/09_feeds.md) for more details). A query request is as follows:

```
{
  handle: str,
  type: str,
  where: [filter],
  order: [str, str],
  limit: int,
}
```

- `handle` is a random handle which can be used to track subsequent responses to the query.
- `type` is the name of any `record` or `feed`.
- `where` is a potentially recursive list of tuples specifying `[operator, condition]`
  - Where `condition` is a tuple of [`field`, `value`], `operator` is one of `=`, `!=`, `!=`, `>`, `<`, `>=`, `<=`
  - Where `condition` is a list of `where`s, `operator` is one of `and`, `or`, `not`.
- `order` is a tuple of `[field, direction]` where `direction` is one of `asc`, `desc`
- `limit` is an integer specifying how many records to return.

Upon receiving a query request, servers MUST query its internal database and return records that match the query, storing the query for subsequent paginated requests. Response is as follows:

```
{
  handle: str,
  next: str?,
  prev: str?,
  total: int,
  data: object[],
}
```

When making subsequent requests, a client must make a GET request to the `/request/<cursor>` endpoint, where `cursor` is a value from either the `prev` or `next` keys of the response. This endpoint returns a standard response.

Servers MUST advertise support for the `/request` endpoint by including `request: {type: [str]}` where `type` is a list of queryable record types.
